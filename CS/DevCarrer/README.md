# 몇개만 추려서 정리.

# 자료구조 & 알고리즘

## 구구단, 이진탐색, 퀵소트 시간복잡도
> 구구단 : O(N^2) [nested loop]  
> 이진탐색 : best : O(NlogN) worst : O(N^2) [skweed tree, root기준 항상크거나 작거나]  
> 퀵소트 : best : O(NlogN) worst : O(N^2) [first pivot을 선택할경우, medium of three해주면 해소됨]   

## DP와 재귀함수 중 어떤것을 더 선호? 시간복잡도 낮은것은
> Activation record(스텍,복귀주소)때문에 DP가 더 time complexity 좋지만, 아무래도 recursion 이용하면 종료조건만 잘 설정하면 쉬워서 일단 구현은 recursion, 이후 dynamic programming 생각해봄  

## 우선순위 큐 동작과정. array, list
> 정렬이 됐나 안됐나에 따라 O(N)이거나 O(1)이다. 배열일때, 리스트일때 다른데 생각을 해보면 됨. 배열이고 정렬안됐으면 뒤에 삽입만하면되는데 삭제는 오래걸림.. 이런식으로  

## 위상정렬, 이분탐색, 다익스트라
![image](https://user-images.githubusercontent.com/84604563/148398830-e98578d8-90fe-47d1-b6b7-f87347537e59.png)

![image](https://user-images.githubusercontent.com/84604563/148398789-7b949252-45e3-453d-abc6-5af7bdb3f760.png)

![image](https://user-images.githubusercontent.com/84604563/148398878-2de3e386-2b71-4548-9baa-56b6bde2af8a.png)

## Array, LinkedList
> Array는 index, 미리 크기 정해둬야하고, 중간에 삽입 삭제 timecomplexity 김  
> LinkedList는 양방향 list, size상관없음, 중간에 넣기 쉬움  

## 스택 vs큐 차이
> LIFO, FIFO  

## 정렬종류 , 퀵소트 설명 ( 추가적인 손코딩 ) 
selection sort, insertion sort, bubble sort, shell sort(insertion + gap O(n root n)), merge sort(divide conquer), quick sort, heap sort, radix sort

# 네트워크 
## HTTP/ HTTPS(TLS(SSL))/ HTTP RESTFUL / HTTP 응답코드 외우기
Hyper Text Transfer Protocol  
SSL -> TSL 로 발전. Diffie Hellman(mod, secret key) -> RSA (Public Key), 443 port.        
HTTP Method (get post put patch delete).. 에서 rest 규칙따라 설계.  
401(아이디없음[허가x]), 403(로그인됐지만 안됨[금지])   

## HTTP 메소드의 get과 post의 차이
> Get : GET은 서버로부터 정보를 조회하기 위해 설계된 메소드  
>  ```www.example-url.com/resources?name1=value1&name2=value2 ?표 붙히고 정보다보임```  
> <br>
> Post : 리소스를 생성/변경하기 위해 설계,  
> ```HTTP 메세지의 Body에 담아서 전송. HTTP 메세지의 Body는 길이의 제한없이 데이터를 전송. GET보단안전.```  

## 웹브라우저에 google.com 치면 일어나는 과정
![image](https://user-images.githubusercontent.com/84604563/148233180-84a48060-cdc2-43d6-a510-fdcb997627c6.png)

1. domain name을 입력하면 DNS를 통해서 그에 맞는 IP주소 알아냄  
2. HTTP를 통해서 그 IP주소와 입력한 url같이 TCP프로토콜 사용, 인터넷으로 서버로 보냄   
3. HTTP 요청 해석해서 정보가져와서, 다시 HTTP 응답. TCP프로토콜사용, 인터넷으로 클라이언트로 보냄  
4. HTTP 요청 해석해서 클라이언트에 보여줌   


## TCP vs UDP (TCP, UDP 특성)
> TCP/IP 4계층에서 transport layer에 있는게 TCP. (어떻게 정보를 주고받을것인가?)  
![image](https://user-images.githubusercontent.com/84604563/148231745-1b7e4b81-44ac-486a-ac38-77305e08cef3.png)

<img width="751" alt="Screen Shot 2022-01-05 at 11 17 46 PM" src="https://user-images.githubusercontent.com/84604563/148232436-c334a590-8fbc-43b5-8d73-95706b676f7f.png">

## TCP의 3way handshaking과 4way handshaking 과정을 그려주세요

TCP : 전송 계층에서 사용하는 프로토콜. 신뢰성을 보장하는 연결형 서비스.  
![image](https://user-images.githubusercontent.com/84604563/148037557-0f96961b-b760-4c34-96a3-6e530e982fe6.png)

> 연결을 설정(Connection Establish) 하는 과정  
> 3way handshaking : 연결하는 과정. 1. A->B : SYN보내기 2. B->A : SYN + ACK(연결해줘) 3. A->B : ACK (데이터도같이ㄱㄴ)  
> 4way handshaking : 끊는 과정 : 1. A->B : FIN보내기 2. B->A : ACK(이거까지보낼게, Time wait) 3. B->A : FIN (끝. 다보냈다) 4. A->B ACK(알겠다.)

## OSI 계층 말하기(각각 알려진 유명 프로토콜)
![image](https://user-images.githubusercontent.com/84604563/148037304-2c89110d-e337-4527-9e6e-d21729433b93.png)

## 프록시 서버란 무엇인가요? 포워드 프록시와 리버스 프록시에 대해 설명해주세요  
> Proxy server :   
> 다른 네트워크 서비스에 간접적으로 접속할 수 있게해주는것. 

<br> 

> 포워드 프록시 서버 : 포워드프록시서버가 요청을 받고 인터넷에 연결하여 결과를 클라이언트에 전달 (forward) 해준다  
> ![image](https://user-images.githubusercontent.com/84604563/148227774-242eb816-e0c8-4c23-819f-436880a2973a.png)

> 리버스 프록시 서버 : 클라이언트가 인터넷에 데이터를 요청하면 리버스 프록시가 이 요청을 받아 내부 서버에서 데이터를 받은 후 클라이언트에 전달한다.
> ![image](https://user-images.githubusercontent.com/84604563/148227801-be30a292-9ede-4f58-98a5-0a5d2f7c63df.png)

## 동기(Synchronous)와 비동기(Asynchronous) 호출에 대해 설명해주세요
> 동기 : 요청과 결과 동시에(요청을 보낸 후 응답(=결과)를 받아야지만 다음 동작이 이루어지는)    
> 비동기 : 요청과 결과 동시 X(요청을 보낸  후 응답(=결과)와는 상관없이 다음방식이 동작)    
동기방식은 매우 간단 but 대기해야 하는 단점   
비동기방식은 복잡하지만 but 다른 작업을 할 수 있음, 자원효율업! 

# DB

## 데이터베이스 무결성 3가지에 대해 설명해주세요
> 기밀성 : 데이터의 보호   
> 무결성 : 데이터 위변조 및 파괴 방지  
> 가용성 : 데이터에 대한 원활한 접근  
> 기무가

## DB 트랙잭션과 트랙잭션 특성 4가지
> db연산 단위, 모아둔것   
> 원자성 Atomicity : 실행되다가 *중단*되지 않는 것을 보장  
> 일관성 Consistency : *일관성* 있는 데이터베이스 상태로 유지  
> 고립성 Isolation : 다른 작업이 *끼어들지 못하도록* 보장  
> 지속성 Durability : *영원히* 반영됨  

## 트랜잭션 고립성 수준(트랜잭션 격리수준)
> 동시에 실행하는 트랜잭션들을 순차적인 실행 상태로 만드는 것은 성능에 좋지 않다.  
![image](https://user-images.githubusercontent.com/84604563/147943481-020bf03f-953e-4958-8843-6015c3362d5d.png)

## NoSQL, RDBMS

![image](https://user-images.githubusercontent.com/84604563/147942693-f17692de-0353-4578-a92e-bcb75a2ba84b.png)

(스키마 : entity, relation, attribute 있는거)   
RDBMS : Oracle, Sqlite  
Nosql : Mongodb .. etc  

![image](https://user-images.githubusercontent.com/84604563/147942855-e6ddcfb6-08c9-4186-9ad2-95fdf6dc4b03.png)

## DB 인덱스 , 인덱스 거는이유, 인덱스에 왜 해쉬 보다 B Tree를 쓰는지?
> index는 자주 나오지 않게 unique한걸로, 빨리참조하려고    
> 성별은 자주나와서 성능 저하, 주민등록번호로 해야지   
> 비교연산자  

## DB 정규화, 비정규화(역정규화)
> 중복최소화 -> 무결성(정확성) 유지, DB저장 용량 줄어듬  
> 읽는 속도 최대


## DB인젝션 공격에 대해 설명해주세요. 그리고 대처법도 알려주세요
> 임의의 SQL 문을 주입하고 데이터베이스가 비정상적인 동작을 하도록 조작
> 자주 사용되는 SQL을 데이터베이스가 이해하기 쉬운 형태로 해석해 놓은 것을 Prepared statement. (권한 있으면 이어나감)   

## 트랜잭션과 세션에 대해 설명해주세요
트랜잭션 : sql문 덩어리, 최소 수행단위 
세션 : 시간(접속후 종료까지)

# 언어(JAVA)

## JAVA면 JVM, 솔리드, 프로그램 실행의 일련과정 
![image](https://user-images.githubusercontent.com/84604563/147926385-283f93a0-a30b-4962-b730-22455eff7f78.png)

> JVM은 운영체제에 종속적  

## 가비지 콜렉터가 동작하는 과정을 설명해주세요
> Stop The World : GC 제외 모든 쓰레드 멈춘다.  
> Mark and Sweep : 1. 사용되고 있는 메모리를 *식별*하는데, 이러한 과정을 Mark라고 한다. 2. Mark가 되지 않은 객체들을 메모리에서 *제거*하는데, 이러한 과정을 Sweep라고 한다.

## 자바에서 Runnable인터페이스와 Thread 클래스의 차이점을 설명해주세요 & 이렇게 두가지 방법이 지원되는 이유를 설명해주세요
> Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없기 때문에 , Runnable 인터페이스를 구현하는 것이 일반적이다.  
> Thread는 간단, Runnable은 확장성이 좋음 

<hr>

## 객체지향의 장점과 단점을 설명해주세요
> 장점 : 1. 재사용성 2. 유지보수 3. 자연적인 모델링  
> 단점 : 1. 실행속도 2. 설계부터 해야해서 개발속도 느림 3. 상속때문에 복잡해질 수도   

<hr>

## 객체지향의 특징을 설명해주세요(3가지 물어볼경우와 5가지 물어볼경우에 답이 다름)
> 캡슐화 : 클래스로 변수나 함수 묶고, 정보은닉 가능.(접근제한자(protected..private..))     
> 다형성 : 부모 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록 해준다.   
> 상속 : 자식 클래스에서 부모 클래스로부터 부모의 모든 자원을 물려 받는 것. 중복피함 (다중상속은안됨)   
> 추상화 : 공통적인 속성이나 기능을 묶어서 이름을 붙이는 것 ( a b d 이런게있다고 치면 이런건 알파벳이라고 묶을 수 있다)  
  

<hr>

## 멀티스레딩의 장단점에 대해 설명해주세요
하나의 프로그램에서 동시에 여러 개의 일을 수행할 수 있도록 해줌 (사실 분산처리를 통해 동시에 실행되는 것 처럼 보이는 것)  

> 장점 : 1. 응답성(사용자가 빠르게느낌) 2. 경제성 (메모리 경제적으로씀) 3. 멀티프로세서 활용 (병렬성 증가. cpu 병렬로사용가능)  
> 단점 : 임계영역(Critical Section) 갈 수 있음. mutax나 semaphore로 해결. lock많이하면 time complexity 증가

## 생성자란 무엇인가요?
> 객체를 생성할 때 항상 실행되는 것으로, 객체를 초기화해주기 위해 맨 처음 실행되는 메소드이다.  
> 인스턴스 생성시 한번실행, return 없다.  

<hr>

## 싱글톤 패턴이란 무엇인가요?
> 객체의 인스턴스가 오직 1개만 생성  
>   
> 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있으므로,  
> 요청이 많은 곳에서 사용하면 효율을 높일 수 있습니다.

<hr>

## 싱글톤 객체의 필요성에 대해 설명해주세요
> 객체가 프로그램 내부에서 단 1개만 생성됨 을 보장  
> 동시성 문제(일관되지않게 읽거나 데이터 손실)도 해결해주는 디자인 패턴   


## 자바의 추상클래스와 인터페이스의 차이점에 대해 설명해주세요
> 추상클래스 : 선언부는 있는데 구현부가 없는 메소드, 상속```extends```을 통해서 사용    
> 인터페이스 : 상속관계가 아니라, 필요한 기능 확장해서 사용```implements```(Serializable: 직렬화할 수 있는, Comparable: 비교할 수 있는, Runnable: 실행할 수 있는)   

<hr>

# 언어(javascript)

## 함수형 프로그래밍(Function Programming)

## 함수형 프로그래밍에 대해 설명해달라
> 함수형 프로그래밍은 순수함수와 보조 함수의 조합을 통해 로직내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

<hr>

## 함수형 프로그래밍에 개념에서 순수함수란 무엇인가
> 순수함수는 같은 입력이 주어지면, 같은 출력을 반환해야하고, side effect(부작용) 이 없어야한다.  
> 결국, 함수형 프로그래밍은 순수함수를 통해 sideeffect를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법  

<hr>

## OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가
> 객체지향은 객체 안에 속성(상태)을 저장하고, 이 속성을 이용해서 메소드를 추가하고 상태변화를 설정하고 조정하기위해 다양한 기능을 사용한다. 이에 반해 함수형 프로그래밍은 상태를 제어하는것보다 속성을 저장하지 않고 없애는데 주력한다.   
> 예를들면, 객체 지향은 속성을 저장하는 필드와 그 필드들을 이용해 기능을 제공하는 메소드를 만들고 클래스를 만듭니다. 반면 함수형은 몇몇 자료구조(list, map, set) 등을 이용해 최적화된 동작을 만들어낸다.
 
<hr>

## 웹 프로토콜

## 웹 프로토콜이란?  
> 웹 프로토콜은 웹에서 쓰이는 통신규약.  

<hr>

## Http 1.1과 2.0의 차이는?
> 가장 큰 차이는 속도이다. 2.0같은 경우는 헤더를 압축해서 보내기도하고, 한번의 연결로 동시에 여러 메시지를 주고 받을 수도 있다.  

<hr>

## 비동기 프로그래밍(Asynchronous)

## AJAX란 무엇인가
> 자바스크립트를 이용해 비동기적으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식  
> 보통은 서버로부터 웹페이지가 반환되면 전체를 갱신해야하는데  / AJAX를 사용하면, 페이지 일부만을 갱신하고도 동일한 효과를 볼 수 있다.  
> 즉, 갱신이 필요한 부분만 로드하여 갱신하면 되므로 빠르고, 부드러운 화면효과를 기대할 수 있음   

<hr>

## Promise와 Callback의 차이점은 무엇이며 각각의 장단점에 대해 설명해달라   
## Promise란 무엇이며 코드가 어떻게 구성되어있는가    

> 둘 다 자바스크립트에서 비동기처리를 위해서 사용되는 패턴이며,  
> Callback 같은 경우 함수의 처리 순서를 보장하기 위해서 함수를 중첩하게 사용되는 경우가 발생해 콜백헬이 발생하는 단점과 에러처리가 힘들다라는 단점이 있다.  
> 그래서 나온게 Promise이며 ES6부터 정식 채택되어 사용중이다.  
> Promoise 생성자 함수를 통해 인스턴스화하며,   
```javascript
// Promise 객체의 생성
const promise = new Promise((resolve, reject) => {
  // 비동기 작업을 수행한다.

  if (/* 비동기 작업 수행 성공 */) {
    resolve('result');
  }
  else { /* 비동기 작업 수행 실패 */
    reject('failure reason');
  }
});
```

> 비동기 처리에 성공하면 resolve메소드를 호출해서 비동기 처리 결과를 후속처리 메소드로 전달한다.  
> 비동기 처리에 실패하면 reject메소드를 호출해서 에러메시지를 후속처리 메소드로 전달한다.  
> 후속처리메소드는 then과 catch가 있다. 둘다 Promise를 반환한다.  
> then 을 가지고 메소드 체이닝을 통하여서 콜백헬 문제를 해결 할 수 있다.  

<hr>

## Async, Await가 무엇이며, 사용해본 경험이 있는가  
> Async, Await와 Promise의 차이는   
> Promise를 더욱 쉽게 사용할 수 있도록 ES2017(ES8) 문법이다.   
> 함수의 앞부분에 async 키워드를 추가하고, 함수 내부에서 Promise의 앞부분에 await 키워드를 사용한다.  
> async, await를 사용할 경우 코드가 간결해지지만, 에러처리를 잡기 위해 try catch를 사용해야한다. 동기적인 코드흐름으로 개발이 가능하다.  

<hr>

## 자바스크립트의 호이스팅(Hoisting)은 어떻게 이루어져 있는가  
> 변수를 선언하고 초기화 했을때 선언부분이 최상단으로 끌어올려지는 현상  
> 예를들어, 코드 상단에서 console.log(a)를 찍고 하단에서 var a=1; 이라고 하였을때 a는 undefined라고 나온다. 이런 현상을 호이스팅이라고한다.  
> 함수의 경우 함수표현식은 호이스팅이 적용되지 않으나 일반 함수선언문은 함수 호이스팅이 적용된다.   

<hr>

## 클로저(Closure)란 무엇이며, 왜 이러한 패턴을 사용하는가

> 반환된 내부함수가 자신이 선언됬을때의 환경인 스코프를 기억하여 자신이 선언되었을때의 환경 밖에서 호출되어도 그 환경에 접근할 수 있는 함수, 자신이 생성될때의 환경을 기억하는 함수   
> 사용 하는 이유 :   
> 1) 현재 상태를 기억하고 변경된 최신 상태를 유지하기 위해  
> 2) 전역 변수의 사용을 억제 하기위해  
> 3) 정보를 은닉하기 위해   

<hr>

## 가비지컬렉터의 역할은? 어떻게 동작?  

> 메모리 할당을 추적하고 할당된 메모리 영역이 필요하지 않은 영역일 경우를 판단해서 회수하는 것.  
> 자바스크립트에서 변수는 직접적으로 참조 값(문자열, 객체, 배열 등)을 담고 있지 않고, 해당 값을 메모리 상에 저장 된다. 그래서 참조 값을 생성하고나서 더이상 참조할 것이 없거나 비어졌을 때 가비지 컬렉터가 동작해서 메모리가 반환됨.(메모리를 다시 재사용할 수 있는 상태가 된다)  

<hr>

## 자바스크립트의 순환참조란? 어떤게 문제이고 해결방법은?

```javascript
function f(){
  var o = {};
  var o2 = {};
  o.a = o2; // o는 o2를 참조한다.
  o2.a = o; // o2는 o를 참조한다.

  return "azerty";
}

f();
```
> 위와 같이 서로 순환되어서 참조되어져서 가비지컬렉터가 작동하지 않고 메모리 누수가 발생된다.  
> null을 할당해서 연결을 끊는 방법을 사용한다.  
> 대부분의 브라우저에서는 Mark and sweep알고리즘을 사용. 그래서 가비지컬렉터가 참조되지 않는 객체가 있을 때 동작하는 것이 아니라 접근 할 수 없는(닿을 수 없는) 객체 일 때 동작한다.  

<hr>

## 자바스크립트의 배열이 실제 자료구조 배열이 아닌데 그 이유는?

> 자바스크립트의 배열은 실제 자료구조의 배열과 다르게 HashMap으로 구현되어있다. 이 HashMap을 구현하기 위해서는 연결리스트로 구현하게 되는데 연결리스트에서 값을 찾기 위해서는 탐색해나가면서 값을 찾는 불상사가 발생한다. 이를 해결하기 위해서 타이핑된배열(Int8Array,Float32Array 등) 이 추가되고 있다.

<hr>

## 이벤트 루프에 대해서 설명, 동시성 모델에 대해서 설명

> 자바스크립트는 싱글 스레드 기반 언어이다. 함수를 실행하면 함수 호출이 스택에 순차적으로 쌓이고 스택의 맨위에서부터 아래로 한번에 하나의 함수만 처리 할 수 있다.    
> 하지만, 자바스크립트에는 이벤트 루프라는것을 통해 동시성을 지원한다. (동시에 일어나는 것이 아니라 동시에 일어나는 것처럼 보이게 하는것이다!)   
> 이벤트 루프는 콜 스택에서 실행 중인 게 있는지 확인하고, Event queue에 작업이 있는지 확인해서 콜스택이 비어있다면 이벤트큐 내의 작업이 콜스택으로 이동되어서 실행된다.   

<hr>

## 프로토타입이란?

> 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거(중복 제거 방법은 기존의 코드를 재사용하는것!!)  

<hr>

## This
## 자바스크립트에서 This는 몇가지로 추론 될수 있는가, 아는대로 말해달라
> 일반함수의 this와 화살표함수의 this로 알고 있다.

<hr>

## 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?

> 자바스크립트의 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든지 this는 전역객체를 가르킴  
> 일반함수의 this는 window(전역)을 가르키며, 화살표 함수의 this는 언제나 상위스코프의 this를 가르킴  

<hr>

## Call, Apply, Bind 함수에 대해 설명해달라

> 3가지 방법은 this를 바인딩하기 위한 방법이다.  
> Call은 this를 바인딩하면서 함수를 호출하는 것, 두번째 인자를 apply와 다르게 하나씩 넘기는 것  
> Apply는 this를 바인딩하면서 함수를 호출하는 것, 두번째인자가 배열  
> Bind는 함수를 호출하는 것이 아닌 this가 바인딩 된 새로운 함수를 리턴함.  

<hr>
   
## var 와 let, const의 차이점은 무엇인가 (function scope와 block scope의 개념에서)

> var은 함수 레벨 스코프를 지원, let,const는 블록레벨 스코프를 지원한다.  
> 하여, 다음과 같이 블록레벨에 foo를 456으로 재선언하는 경우 foo를 456으로 인식  
> 하지만, let이나 const는 전역 변수를 읽는다 블록 안에 있는것을 읽지 않고  

```javascript
var foo = 123; // 전역 변수

console.log(foo); // 123

{
  var foo = 456; // 전역 변수
}

console.log(foo); // 456
```

<hr>

## Class 는 무엇이고, Prototype, fucntion의 ES5 스펙만으로 Class를 구현할수 있는가

> 구현가능하다. 자바스크립트에는 프로토타입이라는 것이 존재하여 클래스처럼 구현할 수 있다.   
> 클래스는 자바스크립트의 프로토타입 기반 패턴의 문법적 설탕이다.  

<hr>

## 타입스크립트를 사용해본 경험이 있는가, 타입스크립트에 대한 본인의 생각과 도입시의 장점을 말해달라

> Typescript는 동적타입언어인 Javascript의 약점을 보완하기 위해서 타입을 지정해주는 것이다.   
> 타입이 필요한 이유는 결론은 메모리를 절약하기 위해서이다. 메모리에 저장된 것을 읽어들일때, 값을 메모리에 저장할때, 값이저장되어있는 것을 참조할때의 크기들을 알아야 하기 때문이다.  
> 또한, 에러를 잡기가 쉬워지고, 다른 동료와 협업 할때 코드의 예측도 가능해지고, 코드에디터의 도움을 더 받을 수 있다.  

<hr>
  
## 라이브러리와 프레임워크에 대해서 설명

> 라이브러리와 프레임워크의 차이는 자유도의 차이 인것 같다. 프레임워크는 짜여진 패턴이나 틀 기반에서 내가 코딩을 하는 것이고, 라이브러리는 내가 가져다 사용해서 자유롭게 사용하는 방식이다.

<hr>

## 두 명의 프론트엔드 개발자가 있다 git을 관리하는 방식?

> git repository를 하나파서 다른 동료가 fork를 해서 사용하는 방식.  
> PM과 팀원의 구조를 가질 수도있고 동시에 Pull request를 가능하게끔 권한을 줄 수 도 있다. 각자의 팀장의 레포가 origin이라하고, 팀원의 포크딴 레포를 rmorigin이라고 한다면 각자의 origin에서 develop브랜치에서 작업을 한뒤 최종 작업이 완료되면 팀장의 origin의 마스터로 push한다.   
 
<hr>

## 메모라이제이션이란?
불필요한 연산이나 계산을 하지 않고 기억을 해놓고 그 기억해놓은 것을 활용하는 방법  

<hr>

## RESTful API 가 무엇인가, 아는대로 다 말해달라  

> REST API는 URI로 접근가능하고 내용이 JSON,XML 등으로 표현된 자원에 대한 행위를 HTTP Method로 정의한다.  
> RESTful하다라는 것은 REST API의 설계의도를 명확하게 지켜주는 것이다. 슬래시를 통해 계층관계를 표시한다던가 숫자는 id를 나타낸다든가 동사보단 명사를 위주로 쓴다든가 하는.  

<hr>

## CORS(Cross-Origin Resource Sharing)는 무엇인가 왜 이러한 방법이 정의 되었으며, 본인이 코드를 작성하면서 CORS와 관련하여서 경험하였던 이슈는 무엇인가

> CORS란 도메인 또는 포트가 다른 서버의 자원을 요청하면 발생 하는 문제   
> 경험 없음.  
> 웹 프론트 측에서 request header에 CORS 관련 옵션을 넣어주고, 서버에서는 해당 프론트 요청을 허용하면 됨  

<hr>

## 프로세스 vs 스레딩
프로세스 : 운영체제로부터 자원을 할당받는 작업의 단위  
스레드 : 프로세스가 할당받은 자원을 이용하는 실행 단위이다.  
> 멀티프로세싱보다 멀티스레딩을 하는 이유는 운영체제로부터 자원을 할당 하는 프로세싱 작업을 많이 하는 것 보다 스레딩을 여러개 하는것이 훨씬 더 시스템 자원을 효율적으로 관리할 수 있다.
 
<hr>

## 이벤트 위임이란?

> 이벤트 위임이란 자식 엘리먼트의 이벤트를 부모엘리먼트에서 감지할 수 있으니 이벤트를 하나하나 등록하는 것이 아니라 부모에게 이벤트를 위임 하는 방법  

<hr>

## DOM이란 
> DOM은 Document Object Model의 약자(문서객채모델)  
> 문서객채모델이란 <html>이나 <body> 같은 html문서의 태그들을 JavaScript가 이용할 수 있는 객체(object)로 만드는것.  
> 넓은 의미로 웹 브라우저가 HTML 페이지를 인식하는 방식을, 좁은 의미로 document 객체와 관련된 객체의 집합.	
	
## DOM을 건드리는 방식과 아닌 방식들의 차이  

> 직접 DOM을 건드리는 경우 DOM의 구조를 파악하고 있어야하며, 클래스명이다 태그명이 바뀌는 경우 다시 DOM을 변경해야한다.  
> Angular의 경우 view와 model을 연결시키는 바인딩작업이 있고 변화감지를 통해서 상태를 보고 있다가 업데이트되는식이다.   
> React의 경우 가상 DOM이 있고, 가상 DOM이 실제 DOM과 비교하여 state가 변화되었는지 감지 한다.   

<hr>

## 반응형 프로그래밍?

> 반응형 프로그래밍이란 데이터 스트림이라는 하나의 일관된 형식으로 만들고, 이 데이터 스트림을 구독하여 데이터 스트림의 상태 변화에 반응하는 방식으로 동작하는 애플리케이션을 만드는 것  
> 예를들어, Tv랑 Tv방송국이 있다고 가정했을때, Tv방송국이 일정한 시간 단위로 영상에 대한 프레임을 계속해서 방출(emit)하고 TV는 방송국을 관찰하고 있다가 새로운 영상을 방출하면 이를 획득하는 방식이다.  
> 여기서 방송국의 역할이 옵저버블, Tv가 옵저버, 영상프레임이 Notification이다.   

<hr>

## Call by value & call by ref

> call by value 는 인자로 값이 넘어올때 복사된 값이 넘어오기 떄문에 중간에 어떤 연산을 해도 변하지 않는다.  
```javascript
var a = 1;
var fun = funcion(b) {
	b=b+1;
}
fun(a)
console.log(a) // 1
```
> 자바스크립트는 기본적으로 원시값을 넘겨주면 call by value 로 작동  
> 함수 내에서 값을 변경하면 함수에 전달된 데이터만 변경될 뿐 함수 전달된 원본 복사본에는 아무런 영향을 미치지 않는다.  

<hr>

## call by reference는 인자로 레퍼런스가 넘어올때 가리키는 값을 복사하는 것이 아니라 참조 값을 넘기는 것

> 참조형 데이터는 그 값의 주소를 말 그대로 참조 할 값의 복사본이나 값 자체가 할당되지 않는다.  
> 참조에 의해 할당된 새 변수는 원본 변수가 가르키는 값과 동일한 값을 가르킨다.  
> 원본 변수와 할당된 변수는 모두 동등하며, 값을 조작하는데 사용될 수 있다. 그래서 할당된 변수(참조)가 변경되면 원본 변수에서도 동일하게 변경된다.  

```javascript
var a = {};
var fun = funcion(b) {
	b.a=1;
}
fun(a)
console.log(a.a) // 1
```

<hr>

## null vs undefined ?
> 기본적으로 둘다 값이 없음을 나타낸다.  
> undefiend는 데이터 타입이자 값을 나타냄.  정의되지 않은 것  
> null은 명시적으로 값이 비어있음을 나타내는데 사용   
> undefined는 변수를 선언만 한더라도 할당되지만, null은 변수를 선언한 후에 null로 값을 바꾼다.  

<hr>

## inline vs inline block ?
> inline은 text크기만큼만 공간을 점유하고 줄바꿈을 하지않음.  
> inline-block은 inline속성과 block속성의 특징을 둘다 가지고 있다. inline속성과 다르게 width,height 적용 가능하고 line-height를 커스텀하게 적용할 수 있다.  

<hr>

## 가상돔 (virtual DOM)

> Virtual DOM은 실제 DOM 변화를 최소화 시켜주는 역할.  

> 먼저 브라우저는 HTML 파일을 스크린에 보여주기 위해 DOM 노드 트리 생성, 렌더트리 생성, 레이아웃, 페인팅 과정을 거칩니다. DOM 노드는 HTML의 각 엘리먼트와 연관되어 있기 때문에 HTML 파일에 20개의 변화가 생기면 DOM 노드가 변경되고 그 이후의 과정역시 20회 다시 이루어 집니다. 작은 변화에도 매우 복잡한 과정들이 다시 실행되기 때문에 DOM 변화가 잦을 경우 성능이 저하됩니다.  

> Virtual DOM은 뷰에 변화가 있다면, 그 변화가 실제 DOM에 적용되기 전에 Virtual DOM에 적용시키고 최종 결과만 실제 DOM에 전달합니다. 따라서 20개의 변화가 있다면 Virtual DOM은 변화된 부분만 가려내어 실제 DOM에 전달하고 실제 DOM은 그 변화를 1회로 인식하여 단 한번의 렌더링 과정만 거치게 됩니다.

<hr>

 
## 자바스크립트 호이스팅에 대해 말해주세요 &  자바스크립트 var, let, const의 차이에 대해 말해주세요
 > 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미  
 > var은 undefined로 호이스팅. 반면 let과 const는 x  

<br>

## 콜백 함수란 무엇인가요? & 콜백함수의 문제점과 해결책은 무엇인가요?  
> CallBack 함수란 이름 그대로 나중에 호출되는 함수를 말한다.비동기 위함.   
> 지저분할 수 있다. nested돼서. -> promise, async, await로 해결   

<br>

## Ajax란 무엇인가요?
> Asynchronous Javascript And Xml(비동기식 자바스크립트와 xml)의 약자    
자바스크립트를 이용해 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능  

<br>

## 가상 돔이란 무엇인가요? 이러한 개념이 등장한 이유는?

![image](https://user-images.githubusercontent.com/84604563/148254187-a3c345ce-0dcd-461e-af5b-c649d84b64a4.png)  

돔 :  HTML 웹 페이지를 인식하는 방식을 계층화시켜 트리구조로 만든 객체(Object) 모델  

<br>

![image](https://user-images.githubusercontent.com/84604563/148362412-15f00088-43f4-4309-ab1f-96db0847736c.png)

가상돔 : 변경된 내용만 DOM에 적용  

<br>

## SPA란 무엇인가요?
> 과거 : 요소를 한번 클릭하면 완전히 새로운 페이지를 서버에서 전송 용량 너무커짐   
> 그래서 SPA (Single Page Application) : 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현  

<br>

## MVVM 패턴에 대해 설명해주세요
![image](https://user-images.githubusercontent.com/84604563/148255070-65b3570b-0951-44ea-b224-405a3b01351d.png)
* Model : 어플리케이션에서 사용되는 데이터와 그 데이터를 처리하는 부분  
* View : UI 부분  
* View Model : View를 표현하기 위해 만든 View를 위한 Model입니다. (View를 나타내 주기 위한 Model이자 View를 나타내기 위한 데이터 처리를 하는 부분)    

<br>
	
# OS

## OS 스레드 , 프로세스 차이
프로세스 : 컴퓨터 프로그램(메모리영역 Code, Data, Stack, Heap의 구조)  
스레드 : 프로세스 내에서 실행되는것(메모리구영역중 Stack만. 나머지는 공유함heap같은거)  
멀티프로세스 : 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행 에러안남 but 오버헤드가능  
멀티스레드 : 하나의 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리 자원공유해서 에러가능. semaphore, mutex, monitor ㄱ  

## 메모리구조/ 스택/ 힙/ 데이터/ 코드 영역 - 선언하면 어느쪽에 저장되는지 설명하기.
code - 코드 저장되는곳  
data - global, static var  
stack - local var, activation record  
heap - 동적할당  

## OS 데드락, 데드락 조건 4가지, 동기화?
> 교착상태   
> 상호배제(Mutual Exclusion), 점유와대기(Hold and wait), 비선점(No Preemption), 환영대기(Circular Wait)   
>(뮤텍스, 세마포어, 모니터)  


## 세그멘테이션, 페이징 (내부단편화 ,외부단편화) & 어떤 단편화를 해결해주나요?
세그멘테이션 : 사용자(개발자)는 자신의 프로그램을 동일한 크기의 페이지 모음으로 인식하기보단, 함수는 함수대로, 자료구조는 자료구조대로 각각 단위 별로 메모리 상에 존재하는 것으로 인식한다.(이게세그먼트)  
세그먼트를 그대로 물리 메모리 운영에 반영해주는 기법을 '세그멘테이션'이라고 한다.  

페이징 : 외부 단편화로 인한 메모리 낭비는 매우 심하다 -> 프로세스를 작은 크기로 나눠서 외부 단편화를 해결 ex)FIFO  

내부단편화 : 낭비  
외부단편화 : 자리없음  

## 임계영역, 뮤텍스, 세마포어에 대해 설명해주세요
> 세마포어는 공유 자원에 세마포어의 변수만큼의 프로세스가 접근할 수 있습니다.  
> 반면에 뮤텍스는 오직 1개만의 쓰레드만 접근할 수 있습니다.  
> 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있습니다.  
> 하지만 뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.  

## 소프트웨어 공학이란
> 소프트웨어의 개발, 운용, 유지보수 등이 **생명 주기 전반**을 체계적이고 서술적이며 정량적으로 다루는 학문  

# 마지막으로 직무 관련 공부, 포트폴리오 문제.

[질문출처 : https://garden1500.tistory.com/m/11]   
[질문출처 : https://sunnykim91.tistory.com/121]   
[질문출처 : 개발자 단톡방]  

